---
globs: src/**/*.rs
description: Axum routing, tracing, Redis caching, and error-handling conventions
---
# Backend Conventions (Rust)

- Use Axum handlers in `src/routes.rs`; wire them in `src/main.rs` with `.route()` and `with_state(Context)`.
- Always add `#[tracing::instrument(skip(ctx))]` to async handlers and internal functions that accept `Context`.
- Prefer returning `Result<_, AppError>` from handlers and convert internal errors via `?` and `From<E> for AppError`.
- Caching via `Context`:
  - Get single: `Context::get_cached` with JSON deserialization.
  - Get multiple: `Context::mget_cached` (chunked, parallel MGET).
  - Memoize: `Context::get_or_set_cached(cache_key, ttl, || async { ... })`.
- TTL constant guidance: For Curius content and profiles, see `CACHE_TTL_SECONDS` in `src/curius/mod.rs`.
- HTTP client: use the shared `Context.http_client` which has retry + tracing middlewares.
- Tracing: initialize with `telemetry::init_tracing_subscriber()` in `main` and use events/spans at info/debug levels.
- Env: `REDIS_URL` defaults to `redis://localhost:6379`. Bind server to `0.0.0.0:3000`.

Adding a new route:
1. Define request DTO with `serde` + optional defaults; export TS with `#[derive(TS)]` and `#[ts(export)]`.
2. Implement handler in `src/routes.rs` returning JSON or a specific response.
3. Register route in `src/main.rs` with `.route("/path", get(handler))`.
4. If the type is exposed to frontend, ensure ts-rs generation step is executed.

